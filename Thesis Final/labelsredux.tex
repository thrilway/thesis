%        File: labelsredux.tex
%     Created: Tue Jun 06 03:00 PM 2017 E
% Last Change: Tue Jun 06 03:00 PM 2017 E
%
% arara: pdflatex: {options: "-draftmode"}
% arara: biber
% arara: pdflatex: {options: "-draftmode"}
% arara: pdflatex: {options: "-file-line-error-style"}
\documentclass[MilwayThesis]{subfiles}

\begin{document}
In this section I will address two questions which \textcite{chomsky2013problems,chomsky2015problems} largely leaves open.
First there is the question of how to label Host-Adjunct structures.
These are cases of XP-YP structures, but generally involve neither movement of host or adjunct, nor agreement between the two.
Chomsky's LA, then, would crash when processing these structures.
I propose, following \textcite{hornstein2009theory} and \textcite{chametzky1996theory}, that Host-Adjunct structures are unlabelled.
How is it that a structure can be unlabelled?
To answer this question we must consider the nature of the labelling process. 

If we consider the labelling process to be a function Label from unlabelled structures to labelled structures, then an unlabelled structure is an impossible output of Label.
If Host-Adjunct structures are unlabelled, then they cannot be the output of Label.
This means one of two things, either Host-Adjunct structures are not interpreted at the CI interface, or they bypass Label.
The first possibility seems to be contradicted by the fact that Adjuncts are interpreted at CI, so I will follow the second possibility.
Consider, then, a structure [XP, ZP], where XP is a host and ZP is an adjunct.
The structure as a whole will bypass Label, but the host XP will be labelled.
It is reasonable to assume, then, that the adjunct ZP will bypass Label, meaning its internal structure will not be labelled in this cycle of Label.\footnote{The astute observer will likely note that this hypothesis contains a significant amount of stipulation.
I address this stipulation in chapter \ref{sec:Conclusion}}

The second question is why labels should be required by the CI interface at all.
My proposed answer is that the label of a complex object determines how that object composes semantically.
While this may seem \textit{ad hoc}, it is actually a quite reasonable hypothesis.
Consider Chomsky's labelling hypothesis as phrased in \Next, and the more standard theory of the CI interface in \NNext.
\ex. A syntactic object is a valid CI object iff it is labellable.

\ex. A syntactic object is a valid CI object iff it composes semantically.

At first glance, these hypotheses are incompatible, giving us three options at resolving the conflict.
The first option would be to reject one of the conflicting hypotheses.
There is no strong evidence, however, to reject either \LLast or \Last, so I will not choose this option.
The second option is to conjoin the iff clauses as in \Next.
\ex. A syntactic object is a valid CI object iff it is labellable and it composes semantically.

This option is unattractive for reasons of theoretical parsimony, so I will not choose it.
The third option is to hypothesize that labelling and composition are identical, and therefore the conflicting hypotheses are equivalent.
We can, then, replace our two conflicting statements with the two compatible statements in \Next and \NNext below.
\ex. A syntactic object composes iff it is labellable.

\ex. A syntactic object is a valid CI object iff it composes.

This move is theoretically attractive partially due to the fact that it mirrors the logic of antisymmetry on the SM interface \parencite{kayne1994antisymmetry}.
In the case of antisymmetry, Kayne identifies asymmetric c-command with linear order, and there is no compelling reason to think that the CI interface should be more complex than the SM interface.

So, what would it mean for labelling and composition to be two sides of the same coin?
Again, it is helpful to consider the SM interface, where asymmetric c-command and linear order are associated because they are isomorphic.
We should expect a similar isomorphism to hold between composition and labels, and, in fact, there seems to be good reason to think that there is such an isomorphism.
Consider the main modes of composition generally assumed by semanticists \parencite[\textit{e.g.}, by][]{heimkratzer1998semantics}, given schematically in \Next.
\ex. 
\a. \textbf{Lexical insertion}\\
\textsc{sem}($\alpha$) = $\alpha^\prime$
\b. \textbf{Function application}\\
\textsc{sem}($\left[ \alpha, \beta \right]$) = \textsc{sem}($\alpha$)(\textsc{sem}($\beta$))
\b. \textbf{Predicate modification}\\
\textsc{sem}($\left[ \alpha, \beta \right]$) = \textsc{sem}$(\alpha)(x) \&$ \textsc{sem}$(\beta)(x)$
\b. \textbf{Predicate abstraction}\\
\textsc{sem}($\left[ \alpha, \beta \right]$) = (Op$x$)(\textsc{sem}($\beta$)($x$))

Each of these modes of composition has a corresponding structure type as identified by label theory, including my modifications thus far.
Lexical insertion operates on a single syntactic atom, \textit{i.e.}, a head, which label theory necessarily distinguishes from other syntactic objects.
Predicate modification is the next most complex operation, it conjoins two (possibly complex) objects without requiring or inducing any ordering of the two, exactly isomorphic with the output of merge: unlabelled and unordered syntactic objects.
Function application, likewise, requires two objects, but these objects are ordered.
Unlike conjunction structures created by predicate modification, which are commutative ($X \& Y = Y \& X$), the function-argument structures created by function application are inherently asymmetric ($X(Y) \neq Y(X)$).
This matches with head-labelled stuctures, which encode a pair of objects (the contents of the structure) and an ordering statement (the label).
Finally, predicate abstraction, which creates structures similar to quantifier structures, requires the content of the two expressions, an ordering between the two, and a variable.
Pair-labelled structures provide this information.

The simplest cases are those structures labelled by heads.
The classes of structures which get head labels are given in \Next.
\ex. \textbf{Head-labelled structures}
\a. $\left\{ \text{X, }\textsc{Root} \right\} \xrightarrow{Label} \left[_\text{X} \text{X, }\textsc{root}  \right]$
\b. $\left\{ \text{X, YP} \right\} \xrightarrow{Label} \left[_\text{X} \text{X, YP} \right]$
\c. $\left\{ t_\text{ZP}, \left\{ \text{X, YP} \right\} \right\}\xrightarrow{Label}\left[_\text{X} t_\text{ZP}, \text{XP} \right]$

I propose that in these cases, the objects compose by function application, with the label being the function and the non-labelling constituent being the argument.
So, for instance, a DP is interpreted as the function D, with NP as an argument.
\ex. \textsc{sem}($\left[_\textit{the} \textit{the, ball} \right]$) = \textsc{sem}(\textit{the})(\textsc{sem}(\textit{ball}))

The next case is that of structures labelled by feature-pairs.
These structures, tend to be the result of internal Merge, which is generally associated with operator-variable structures.
I hypothesize, then, that feature-pair labels signal that a complex object is to be interpreted as an operator-variable structure.
For instance the Wh-question structure in \Next[a] is interpreted as in \Next[b].
\ex. \textsc{sem}($\left[_{\langle Q,Q \rangle} \textit{Who}_Q, \left[ \text{C}_Q+\textit{did}, \left[ \textit{Mary see } t_{Who} \right] \right]  \right]$) = (Wh\textit{x})(\textsc{sem}(\textit{Mary saw x}))

Finally, the case of unlabelled structures, which is identical to the case of Host-Adjunct structures.
In this case, objects compose by conjunction.
Consider the interpretation of the structure in \Next.
\ex. \textsc{sem}($\left[_\emptyset \textit{run, swiftly} \right]$) =  $(\lambda e)(\textsc{sem}(\textit{run})(e) \& \textsc{sem}(\textit{swiftly})(e))$


I have identified Kayne's (\citeyear{kayne1994antisymmetry}) theory of the SM interface as an inspiration for my proposal, and I would like to say a little more about the similiarities between his and my hypotheses.
Rather than positing active process, be it simple or intricate, for linearizing a hierarchical structure, Kayne suggests that linear order is the product of a passive isomorphism.
Since asymmetric c-command \textit{is} a linear, or total, order, a hierarchical structure can be mapped to a linear string based purely on properties of that structure.
The idea that an interface between mental modules should be passive, is in keeping with the very idea of modularity.
If the SM module and the Narrow Syntax module are truly independant, then we would not expect there to be any specialization of one in order to interact with the other.
My proposal for the CI interface is, I believe, a step towards a passive interface.
Although evidence for the nature of the CI module is not as readily available as it is for the nature of the SM module, the working, albeit tacit, assumption seems to be that the CI module deals in representations that are formally very similar to formulas of predicate logics.
If we assume a predicate logic with operators ($\forall$, $\exists$, $Wh$, M,\ldots), functions/predicates ($P, Q, f, g,$\ldots), variables ($x, y, z,$\ldots), and conjunction ($\&$), then we can see how there could be an isomorphism between labelled syntactic objects and formulas of this logic.

Consider the simplest case, that of unlabelled stuctures mapping to conjoined formulas.
Conjunction is symmetric, meaning that $\varphi \& \psi = \psi \& \phi$ where $\phi$ and $\psi$ are formulas.
Similarly, an unlabelled syntactic object is symmetric; neither of its component parts is more prominent than the other.
So, unlabelled SOs are isomorphic with conjoined formulas.
The next case is that of the mapping between head-labelled SOs and function-argument terms.
Like conjunction, function-argument terms are binary, but unlike conjunction, there is an asymmetry between function and argument; the function is more prominent than its argument
A head-label of a SO is able to indicate the direction of that asymmetry, that is, if the label is a head, it indicates which component of the SO is/contains the function.
In fact, in some representations of bare phrase structure, the label of a phrase is represented as an arrow, pointing to the brach that projects.
\ex. <+ArrowLabels+>

So, head-labelled SOs and function-argument terms, both being binary and asymmetric, are isomorphic.

\end{document}
